{
  "version": 3,
  "file": "swimming.css",
  "sources": [
    "../src/App.svelte",
    "../../scrollmation/Scrollmation.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { quadOut as easing } from 'svelte/easing'\n  import Scrollmation, {\n    toHomeRatio,\n    toStartRatio,\n    toEndRatio,\n    toRangeRatio,\n    fullRangePx,\n    toHomePx,\n    toEndPx,\n    toStartPx\n  } from \"scrollmation\";\n\n  let x = 0;\n  let c = 0;\n  let scrollToPosition = null;\n  // let dir = 1\n\n  // let interval = 1;\n  // let i = setInterval(() => {\n  //   c += 0.12;\n  // }, interval);\n\n  function onScroll(evt) {\n    c = toRangeRatio(evt.detail)*440;\n    // console.log({\n    //   // toHomeRatio: toHomeRatio(evt.detail),\n    //   // toStartRatio: toStartRatio(evt.detail),\n    //   // toEndRatio: toEndRatio(evt.detail),\n    //   // toRangeRatio: toRangeRatio(evt.detail),\n    //   // fullRangePx: fullRangePx(evt.detail),\n    //   // toHomePx: toHomePx(evt.detail),\n    //   // toEndPx: toEndPx(evt.detail),\n    //   // toStartPx: toStartPx(evt.detail)\n    // });\n  }\n\n  function scrollTo(pos) {\n    scrollToPosition = pos;\n  }\n\n  function onClickPrev() {\n    scrollTo(\"start\");\n  }\n\n  function onClickNext() {\n    scrollTo(\"end\");\n  }\n\n  function onKeyDown({ key }) {\n    if (key === \"ArrowRight\" ) {\n      scrollTo(\"start\");\n    }\n    if (key === \"ArrowUp\" || key === \"ArrowDown\") {\n      scrollTo(\"home\");\n    }\n    if (key === \"ArrowLeft\") {\n      scrollTo(\"end\");\n    }\n  }\n\n  $: x = c-20 ;\n  $: y = Math.cos(x / 60);\n</script>\n\n<style>\n  .sincontainer {\n    top: 0;\n    left: 0;\n    height: 100%;\n    width: 100%;\n    position: absolute;\n    z-index: -1;\n    padding: 20px;\n  }\n\n  .sindot {\n    position: absolute;\n    border-radius: 10px;\n    fill: #f00;\n    opacity: 0.5;\n    stroke-width:0;\n    \n  }\n  .maindot{\n\n    r: 10;\n  }\n</style>\n\n<svelte:window on:keydown={onKeyDown} />\n  <!-- <a href=\"#\" on:click|preventDefault={onClickPrev}>prev</a>\n  <a href=\"#\" on:click|preventDefault={onClickNext}>next</a> -->\n<svg class=\"sincontainer\">\n  \n  {#each new Array(90).fill() as d, i}\n    <circle \n      class=\"sindot\"\n      cx=\"{(x - i ) / 3.6 + 5}%\"\n      cy=\"{Math.cos((x - i*0.8) / 15) * 45+50}%\"\n      r=\"{(45- Math.abs(i-45))/9}\" />\n  {/each}\n\n  <circle\n    class=\"sindot maindot\"\n    cx=\"{x / 3.6}%\"\n    cy=\"{y * 45 + 50}%\"\n    r=\"5\"\n    />\n\n</svg>\n<Scrollmation \n  on:scroll={onScroll} \n  duration={4000}\n  startPos={400}\n  endPos={400}\n  homePos={100}\n  {scrollToPosition}\n  {easing}\n>\n  <div slot=\"fg\" />\n\n</Scrollmation>\n",
    "<script context=\"module\">\n    export const toHomeRatio = ({\n        homeScrollPos,\n        scrollPosPx,\n        startScrollPosPx,\n    }) => (homeScrollPos - scrollPosPx) / (homeScrollPos - startScrollPosPx)\n\n    export const toStartRatio = ({\n        homeScrollPos,\n        scrollPosPx,\n        startScrollPosPx,\n    }) => (scrollPosPx - startScrollPosPx) / (homeScrollPos - startScrollPosPx)\n\n    export const toEndRatio = ({\n        scrollPosPx,\n        endScrollPosPx,\n        homeScrollPos,\n    }) => (scrollPosPx - endScrollPosPx) / (homeScrollPos - endScrollPosPx)\n\n    export const toRangeRatio = ({\n        scrollPosPx,\n        endScrollPosPx,\n        startScrollPosPx,\n    }) => (scrollPosPx - endScrollPosPx) / (startScrollPosPx - endScrollPosPx)\n\n    export const fullRangePx = ({ endScrollPosPx, startScrollPosPx }) =>\n        endScrollPosPx - startScrollPosPx\n\n    export const toHomePx = ({ homeScrollPos, scrollPosPx }) =>\n        homeScrollPos - scrollPosPx\n\n    export const toEndPx = (endScrollPosPx, scrollPosPx) =>\n        endScrollPosPx - scrollPosPx\n\n    export const toStartPx = (startScrollPosPx, scrollPosPx) =>\n        startScrollPosPx - scrollPosPx\n</script>\n\n<script>\n    import { afterUpdate, createEventDispatcher, onMount } from 'svelte'\n    import { tweened } from 'svelte/motion'\n    import { cubicOut, linear } from 'svelte/easing'\n    const dispatch = createEventDispatcher()\n\n    let contentHeight\n    let containerHeight\n    let container\n\n    let scrollPosPx = 0\n    let animatingScroll = false\n    let endScrollPosPx\n    let startScrollPosPx = 0\n    let prevScrollPosPx\n    let targetScollPx\n    let scrollDir\n    let targetPos = 'home'\n    let loading = true\n\n    export let startPos = 0 // px past the end\n    export let homePos = 0 //px from the top\n    export let endPos = 100 // px above the top - or negative value for before the end\n    export let duration = 900\n    export let easing = cubicOut\n    export let scrollData = {}\n    export let isPrevNav = false\n    export let scrollToPosition = null\n    export let jumpToPosition = null\n    export let pgId = 0\n\n    async function onScroll(e) {\n        prevScrollPosPx = scrollPosPx\n        scrollPosPx = e.target.scrollTop\n        if (!animatingScroll) {\n            progress.set(scrollPosPx, { duration: 0 })\n        }\n\n        let action = null\n\n        if (prevScrollPosPx !== scrollPosPx) {\n            dispatch('scroll', scrollData)\n            if (scrollPosPx === endScrollPosPx) {\n                action = 'next'\n            }\n            if (scrollPosPx === startScrollPosPx) {\n                action = 'prev'\n            }\n\n            if (scrollPosPx === homeScrollPos) {\n                action = 'home'\n            }\n\n            if (animatingScroll && scrollPosPx === targetScollPx) {\n                dispatch(action, scrollData)\n                return\n            }\n\n            if (!animatingScroll && action) {\n                dispatch(action, scrollData)\n            }\n        }\n    }\n\n    function onWheel(e) {\n        if (animatingScroll) {\n            e.preventDefault()\n        }\n    }\n\n    export let progress = tweened(0, {\n        duration,\n        easing,\n    })\n\n    export async function jumpToPos(destPos) {\n        return await scrollToPos(destPos, false)\n    }\n\n    export async function scrollToPos(destPos = 'home', anim = true) {\n        if (!destPos) {\n            return\n        }\n        targetPos = destPos\n        switch (destPos) {\n            case 'offscreen':\n                targetScollPx = endScrollPosPx + 100\n                break\n            case 'start':\n                targetScollPx = startScrollPosPx\n                break\n            case 'end':\n                targetScollPx = endScrollPosPx\n                break\n            case 'beforeStart':\n                targetScollPx = startScrollPosPx + 1\n                break\n            case 'beforeEnd':\n                targetScollPx = endScrollPosPx - 1\n                break\n            default:\n                targetScollPx = homeScrollPos\n                break\n        }\n        if (anim) {\n            animatingScroll = true\n            await progress.set(targetScollPx)\n            animatingScroll = false\n        } else {\n            await progress.set(targetScollPx, { duration: 0 })\n        }\n    }\n\n    async function initPos(p) {\n        setTimeout(async () => {\n            if (isPrevNav) {\n                await scrollToPos('beforeEnd', false)\n            } else {\n                await scrollToPos('beforeStart', false)\n            }\n            animatingScroll = true\n            loading = false\n            await scrollToPos('home')\n        }, 200)\n    }\n\n    $: if (animatingScroll) container.scrollTop = $progress\n    $: endScrollPosPx = containerHeight + contentHeight + endPos + startPos\n    $: homeScrollPos = containerHeight - homePos + startPos\n    $: scrollDir = scrollPosPx - prevScrollPosPx\n    $: scrollToPos(scrollToPosition)\n    $: jumpToPos(jumpToPosition)\n    $: initPos(pgId)\n    $: {\n        scrollData = {\n            contentHeight,\n            containerHeight,\n            scrollPosPx,\n            endScrollPosPx,\n            startScrollPosPx,\n            homeScrollPos,\n            scrollDir,\n        }\n    }\n</script>\n\n<style>\n    .scrollmation-container {\n        width: 100%;\n        height: 100%;\n        overflow: auto;\n        scrollbar-width: none;\n        overscroll-behavior: none;\n    }\n    .scrollmation-container::-webkit-scrollbar {\n      display: none;\n    }\n    .scrollmation-scroll-spacer{\n      height: 1px;\n    }\n\n    .scrollmation-fg{\n      width: 100%;\n      padding-right: 65px;\n    }\n</style>\n\n<div\n    class=\"scrollmation-container\"\n    bind:this={container}\n    bind:clientHeight={containerHeight}\n    on:scroll={onScroll}\n    on:wheel={onWheel}\n    style=\"opacity: {loading ? 0 : 1}\">\n    {#if !loading}\n        <div\n            class=\"scrollmation-fg\"\n            bind:clientHeight={contentHeight}\n            style=\"margin-top: {containerHeight + startPos}px; margin-bottom: {containerHeight + endPos}px\">\n            <slot name=\"fg\" />\n            <div class=\"scrollmation-scroll-spacer\">&nbsp</div>\n\n        </div>\n    {/if}\n</div>\n"
  ],
  "names": [],
  "mappings": "AAkEE,aAAa,eAAC,CAAC,AACb,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,CACP,MAAM,CAAE,IAAI,CACZ,KAAK,CAAE,IAAI,CACX,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,EAAE,CACX,OAAO,CAAE,IAAI,AACf,CAAC,AAED,OAAO,eAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,aAAa,CAAE,IAAI,CACnB,IAAI,CAAE,IAAI,CACV,OAAO,CAAE,GAAG,CACZ,aAAa,CAAC,AAEhB,CAAC,AACD,uBAAQ,CAAC,AAEP,CAAC,CAAE,EAAE,AACP,CAAC;ACkGC,uBAAuB,cAAC,CAAC,AACrB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,QAAQ,CAAE,IAAI,CACd,eAAe,CAAE,IAAI,CACrB,mBAAmB,CAAE,IAAI,AAC7B,CAAC,AACD,qCAAuB,mBAAmB,AAAC,CAAC,AAC1C,OAAO,CAAE,IAAI,AACf,CAAC,AACD,yCAA2B,CAAC,AAC1B,MAAM,CAAE,GAAG,AACb,CAAC,AAED,8BAAgB,CAAC,AACf,KAAK,CAAE,IAAI,CACX,aAAa,CAAE,IAAI,AACrB,CAAC"
}